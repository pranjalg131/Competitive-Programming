/*
Balika Vadhu- Problem

Anandi and Jagya were getting married again when they have achieved proper age.
Dadi Sa invited Alok Nath to do the kanyadaan and give blessings. Alok Nath has
2 blessings. Each bessing is in the form of a string consisting of lowercase
charaters(a-z) only. But he can give only one blessing of K length because some
priest told him to do so. Thus he decides to generate a blessing using the other
two blessings. While doing this he wants to ensure that happiness brought into
their life by his blessing is maximum. The generated blessing is a common
subsequence of length K of the two blessings he has. Happiness of the blessing
he generates is calculated by the sum of ASCII values of characters in the
blessing and he wants the happiness to be maximum. If he is not able to generate
a common subsequence of length K then the happiness is 0 (zero). Alok Nath comes
to you and asks you to find the maximum happiness that can be generated by the
two blessings he has.

Input Specification
First line consists of number of test cases t. Each test case consists of two
strings b1 (blessing 1),b2 (blessing 2) and an integer K, each of them in
separate lines.

Output Specification
Output consists of t lines each containing an integer denoting the maximum
happiness value that can be generated by the two blessings.

Constraint
1 <= t <= 50
1 <= length(b1) , length(b2) <= 100
1 <= K <= 100

Sample Input
2
asdf
asdf
3
anandi
jagya
3
Sample Output
317
0
*/
#include <bits/stdc++.h>
using namespace std;

template <typename A, typename B>
string to_string(pair<A, B> p);

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p);

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p);

string to_string(const string& s) { return '"' + s + '"'; }

string to_string(const char* s) { return to_string((string)s); }

string to_string(bool b) { return (b ? "true" : "false"); }

string to_string(vector<bool> v) {
    bool first = true;
    string res = "{";
    for (int i = 0; i < static_cast<int>(v.size()); i++) {
        if (!first) {
            res += ", ";
        }
        first = false;
        res += to_string(v[i]);
    }
    res += "}";
    return res;
}

template <size_t N>
string to_string(bitset<N> v) {
    string res = "";
    for (size_t i = 0; i < N; i++) {
        res += static_cast<char>('0' + v[i]);
    }
    return res;
}

template <typename A>
string to_string(A v) {
    bool first = true;
    string res = "{";
    for (const auto& x : v) {
        if (!first) {
            res += ", ";
        }
        first = false;
        res += to_string(x);
    }
    res += "}";
    return res;
}

template <typename A, typename B>
string to_string(pair<A, B> p) {
    return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";
}

template <typename A, typename B, typename C>
string to_string(tuple<A, B, C> p) {
    return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " +
           to_string(get<2>(p)) + ")";
}

template <typename A, typename B, typename C, typename D>
string to_string(tuple<A, B, C, D> p) {
    return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " +
           to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";
}

#define CERR cout

void debug_out() { CERR << endl; }

template <typename Head, typename... Tail>
void debug_out(Head H, Tail... T) {
    CERR << " " << to_string(H);
    debug_out(T...);
}

#ifndef ONLINE_JUDGE
#define dbg(...) CERR << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define dbg(...) 42
#endif

#define ar array<ll, 2>
#define ll long long
#define in insert
#define pb push_back
#define vt vector
#define P_Q(x) priority_queue<x>
#define p_q(x) priority_queue<x, vector<x>, greater<x>>
#define For(i, n) for (ll i = 0; i < n; i++)
#define Rev(i, n) for (ll i = n - 1; i >= 0; i--)
#define FOR(i, n) for (ll i = 1; i <= n; i++)
#define REV(i, n) for (ll i = n; i >= 1; i--)
#define Rep(i, a, b) for (ll i = a; i <= b; i++)
#define all(x) (x).begin(), (x).end()
#define sz(x) (int)(x).size()

const ll mod = 1e9L + 7;
const ll INF = 1e18L + 5;
const ll mxN = 2e5 + 1;

int getBlessing(string s1, int m, string s2, int n, int k) {
    vt<vt<vt<int>>> dp(m + 1, vt<vt<int>>(n + 1, vt<int>(k + 1, 0)));

    for (int i = 1; i < dp.size(); i++) {
        for (int j = 1; j < dp[i].size(); j++) {
            for (int p = 1; p <= k; p++) {
                if (s1[i - 1] == s2[j - 1]) {
                    int ans1 = dp[i - 1][j - 1][p - 1] + (int)s1[i - 1];
                    int ans2 = dp[i - 1][j][p];
                    int ans3 = dp[i][j - 1][p];
                    dp[i][j][p] = max(ans1, max(ans2, ans3));
                } else {
                    int ans1 = dp[i - 1][j][p];
                    int ans2 = dp[i][j - 1][p];
                    dp[i][j][p] = max(ans1, ans2);
                }
            }
        }
    }

    // dbg(dp);

    return dp[m][n][k];
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        string s1, s2;
        cin >> s1 >> s2;
        int k;
        cin >> k;

        int m = s1.length();
        int n = s2.length();

        int ans = getBlessing(s1, m, s2, n, k);

        cout << ans << "\n";
    }

    return 0;
}